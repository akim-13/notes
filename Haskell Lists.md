---
tags:
  - cm12003
  - CS
  - programming
links: "[[Haskell]]"
---

# Haskell Lists
- A **list** is a sequence of elements of the same type.
- If the **elements** have **type** `a`, the list has type `[a]`:
    ```haskell
    [1,2,3,4,5] :: [Int]
    [True,False] :: [Bool]
    ['a','b','c'] :: [Char]
    ["Brouwer","Heyting","De Bruijn","Dijkstra"] :: [String]
    [ [3], [1,8], [], [4,5,6] ] :: [[Int]]
    ```
- A **`String`** is just a list of characters: 
    ```haskell
    "abc" :: String  ==  ["a","b","c"] :: [Char]
    ```
- Lists are **defined using** two **constructors**:
    - `[]` (**nil**) - the empty list.
    - `x:xs` (**cons**) - put a "head" element `x` on top of a "tail" list `xs`. Importantly, it does *not* work the other way around.
    ```haskell
    ghci> 1 : [2,3]             ghci> 1 : 2 : 3 : []
    [1,2,3]                     [1,2,3]
    
    ghci> 'a' : "bcd"           ghci> 1 : 2 : 3 : [4,5]
    "abcd"                      [1,2,3,4,5]

    ghci> 1 : (2 : (3 : [] ))   ghci> ((1 : 2) : 3) : []
    [1,2,3]                     * error ...
    ```
 ^a73fd4
- The notation `[1,2,3]` is **syntactic sugar** for the internal definition: `1 : 2 : 3 : []`.
- Lists can be **built** recursively using nil and cons as functions:
    ```haskell
    countdown :: Int -> [Int]
    countdown x
    | x <= 0    = []
    | otherwise = x : countdown (x-1)
    --
    ghci> countdown 5   ghci> countdown (-13)
    [5,4,3,2,1]         []
    ```
    - **Examples** of recursively built lists with [[Haskell Constructors & Pattern Matching | pattern-matching]]:
        ```haskell
        -- Sum integers in a list
        total :: [Int] -> Int
        total [] = 0
        total (first_element:the_rest) = first_element + total the_rest
        -----
        -- Every following line outputs 6.
        ghci> total [1..3]
        6
        ghci> total (1 : [2,3]) -- Matching (x:xs) pattern
        ghci> 1 + total [2,3]
        ghci> 1 + total (2 : [3])
        ghci> 1 + 2 + total ([3])
        ghci> 1 + 2 + total (3 : [])
        ghci> 1 + 2 + 3 + total []
        ghci> 1 + 2 + 3 + 0
        ```
 
        ```haskell
        -- Add an element to the end of a list
        snoc :: Int -> [Int] -> [Int]
        snoc x [] = [x]
        snoc x (y:ys) = y : snoc x ys
        -----
        -- Every following line outputs [1,2,3,4].
        ghci> snoc 4 [1,2,3]
        [1,2,3,4]
        ghci> snoc 4 (1 : [2,3])
        ghci> 1 : snoc 4 ([2,3])
        ghci> 1 : snoc 4 (2 : [3])
        ghci> 1 : 2 : snoc 4 ([3])
        ghci> 1 : 2 : snoc 4 (3 : [])
        ghci> 1 : 2 : 3 : snoc 4 []
        ghci> 1 : 2 : 3 : [4]
        ```
 
        ```haskell
        -- Reverse a list, inefficiently.
        rev :: [Int] -> [Int]
        rev [] = []
        rev (x:xs) = snoc x (rev xs)
        ```

- **List comprehensions** can be used to build lists by combining [[./Haskell Standard Functions.md | map and filter]]:
    ```haskell
    ghci> [ 3*n + 1 | n <- [0..10] , even n ]
    [1,7,13,19,25,31]
    -- I.e. make the list of all numbers 3*n + 1, where
    -- n is an element of the list [0..10], and
    -- n is even
    ```
    - In the example above, the expression `3*n + 1` is `map`ed onto every element of the list generated by `n <- [0..10]` (called a **generator**) after it's `filter`ed by a **guard** `even n`. So the underlying structure is:
        ```haskell
        -- < and > are not part of the syntax.
        [ <map> | <generators>, <filters>]
        ```
    - The syntax is very similar to mathematical **set comprehensions**:
        $$ \{ 3n + 1 | n \in \mathbb{N}, n \text{ is even}\} $$

    - The same list can be achived by using [[./Haskell Standard Functions.md | maps and filters]] or [[./Haskell Functions.md#^sections | sections]] and [[./Haskell Functions.md#^func-comp | compositions]]:
        ```haskell
        thatlist :: [Int]
        thatlist = map f (filter even [0..10])
            where f n = 3*n + 1

        thatlist :: [Int]
        thatlist = (map ((+1).(3*)) . filter even) [0..10]
        ```
        However, list comprehensions are noticeably easier to read.

    - List comprehensions can help to work with **indexed lists**, which is a very common pattern:
    ```haskell
    ghci> xs = ["Hello", ",", "world", "!"]

    -- E.g. pick every odd element of the list:
    ghci> [ snd p | p <- (zip [1..] xs), odd (fst p) ]
    ["Hello","world"]

    -- Or even more compactly with pattern matching:
    ghci> [ w | (i,w) <- (zip [1..] xs), odd i ]
    ["Hello","world"]
    ```
    - Note that comprehensions may use **multiple generators and guards**:
    ```haskell
    ghci> [n ++ " " ++ m | n <- ["Mickey","Donald"], m <- ["Mouse","Duck"]]
    ["Mickey Mouse","Mickey Duck","Donald Mouse","Donald Duck"]

    ghci> [ (n,m) | n <- [1..3], m <- [n..3] ]
    [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]

    ghci> [ n*m | n <- [1..10], m <- [1..n], even n, odd m]
    [2,4,12,6,18,30,8,24,40,56,10,30,50,70,90]
    ```
    Adding generators is similar to nesting `for` loops in other langueages.
